<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Minecraft project page" />
  <title>Minecraft Project | Project</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css" />
</head>

<body data-project-key="minecraft-project">  <header class="bar">
    <div class="wrap">
      <a class="back" href="../../index.html#projects">Back to projects</a>
      <div class="title" id="projectTitle">Minecraft Project</div>
    </div>
  </header>

  <main class="wrap">
    <section class="hero">
      <h1 id="headline">Minecraft Project</h1>
      <p class="muted" id="lede">
        A C++ voxel sandbox prototype that explores chunked world streaming, mesh generation, and real time OpenGL rendering, built as a foundation for a Minecraft style engine.
      </p>
      <div class="tags" aria-label="Project tags">
        <span class="tag">C++</span>
        <span class="tag">GLFW</span>
        <span class="tag">GLEW</span>
        <span class="tag">GLM</span>
      </div>
    </section>

    <section class="card" id="video">
      <div class="card-head">
        <h2>Video</h2>
      </div>

      <div class="video-shell" id="videoShell" role="group" aria-label="Embedded video">
        <iframe
          id="ytFrame"
          class="video-frame"
          src="https://www.youtube-nocookie.com/embed/QWHR6ZsEq7o"
          title="YouTube video"
          loading="lazy"
          referrerpolicy="strict-origin-when-cross-origin"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          allowfullscreen
        ></iframe>
      </div>
    </section>

    <section class="card" id="gallery">
      <h2>Screenshots</h2>

      <div class="gallery" aria-label="Screenshot gallery">
        <a class="shot" href="assets/shot-1.png" target="_blank" rel="noreferrer">
          <img src="assets/shot-1.png" alt="Screenshot 1" />
          <div class="shot-ph">assets/shot-1.png</div>
        </a>
        <a class="shot" href="assets/shot-2.png" target="_blank" rel="noreferrer">
          <img src="assets/shot-2.png" alt="Screenshot 2" />
          <div class="shot-ph">assets/shot-2.png</div>
        </a>
        <a class="shot" href="assets/shot-3.png" target="_blank" rel="noreferrer">
          <img src="assets/shot-3.png" alt="Screenshot 3" />
          <div class="shot-ph">assets/shot-3.png</div>
        </a>
        <a class="shot" href="assets/shot-4.png" target="_blank" rel="noreferrer">
          <img src="assets/shot-4.png" alt="Screenshot 4" />
          <div class="shot-ph">assets/shot-4.png</div>
        </a>
      </div>
    </section>

    <section class="card" id="writeup">
      <h2>Project write-up</h2>

      <div class="prose">
        <p>
          I built a Minecraft-style voxel world prototype in C++ using OpenGL. The goal was to learn the full pipeline for a
          3D sandbox: chunked world data, mesh generation, a texture atlas, and a smooth realtime render loop, while keeping the
          code structured enough to grow into a real game.
        </p>

        <h3>What it is</h3>
        <ul>
          <li><strong>Type:</strong> voxel sandbox prototype (Minecraft-style renderer + chunked world streaming)</li>
          <li><strong>Tech:</strong> C++, OpenGL (GLFW/GLEW), GLM, stb_image, GLSL shaders</li>
          <li><strong>World format:</strong> chunked blocks (16 × 16 × 64 per chunk)</li>
          <li><strong>Single-player:</strong> yes</li>
        </ul>

        <h3>Highlights</h3>
        <ul>
          <li>
            <strong>Background world streaming:</strong> a dedicated generation thread populates chunks around the player so the
            render loop stays responsive.
          </li>
          <li>
            <strong>Chunk-based rendering:</strong> chunks are tracked in hash maps (data vs. renderer), and missing renderers
            are built progressively outward from the player.
          </li>
          <li>
            <strong>Texture atlas workflow:</strong> blocks use atlas UVs, sampled with nearest filtering for a crisp
            pixel-art look.
          </li>
          <li>
            <strong>Rendering efficiency foundations:</strong> each block tracks active faces, enabling face culling so only
            visible sides are pushed into the chunk mesh.
          </li>
          <li>
            <strong>Camera feel:</strong> mouse-look updates yaw/pitch and direction vectors, plus a visibility test that can be
            used for chunk culling.
          </li>
        </ul>

        <h3>How it works</h3>
        <p>
          The program creates a window and OpenGL context, then runs two loops: the main thread handles input, updates, and
          rendering; a second thread handles world generation. The generation thread repeatedly:
        </p>
        <ul>
          <li>
            Computes the player’s current chunk using the camera position (x/z divided by 16, floored).
          </li>
          <li>
            Ensures a buffer of chunk data exists around the player (within a render-distance radius).
          </li>
          <li>
            Builds exactly one missing chunk renderer at a time, scanning in an expanding ring around the player so nearby
            chunks appear first.
          </li>
        </ul>
        <p>
          Each chunk stores block types (air, grass, dirt, sand). When a chunk renderer is created, it generates vertex and
          index buffers for the visible faces, assigns atlas UVs per face, and draws with a simple shader that samples the atlas
          texture.
        </p>

        <h3>What I would improve next</h3>
        <ul>
          <li>
            <strong>Thread safety:</strong> protect shared maps (chunk data and renderers) with proper synchronization to avoid
            race conditions as the project scales.
          </li>
          <li>
            <strong>Chunk unloading:</strong> add an LRU-style cache so far-away chunks are unloaded from RAM and GPU memory.
          </li>
          <li>
            <strong>Meshing upgrades:</strong> implement greedy meshing to dramatically reduce triangle count and boost FPS.
          </li>
          <li>
            <strong>Gameplay loop:</strong> add block breaking/placing, simple physics/collision, and saving/loading the world.
          </li>
          <li>
            <strong>Visual polish:</strong> lighting (even basic sunlight + ambient), fog, and better frustum/occlusion culling.
          </li>
        </ul>
      </div>
    </section>

    <section class="card" id="links">
      <h2>Links</h2>
      <div class="actions">
        <a class="btn" href="https://github.com/GitEulerAngles/Minecraft" target="_blank" rel="noreferrer">GitHub</a>
      </div>
    </section>
  </main>

  <footer class="foot">
    <div class="wrap">© <span id="year"></span></div>
  </footer>

  <script src="script.js"></script>
</body>
</html>
